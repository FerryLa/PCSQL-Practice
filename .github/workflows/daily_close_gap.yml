name: Daily Close (mark all past blanks as âŒ)

on:
  schedule:
    - cron: '5 15 * * *'   # ë§¤ì¼ 00:05 KST
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  close:
    runs-on: ubuntu-latest
    env:
      TZ: Asia/Seoul
      README_PATH: 01_cert_week_7/README.md
      START_DATE: '2025-10-01'

    permissions:
      contents: write
      pull-requests: write

    steps:
      # develop ë¸Œëœì¹˜ë¥¼ ì²´í¬ì•„ì›ƒ
      - name: Checkout develop
        uses: actions/checkout@v4
        with:
          # develop ë¸Œëœì¹˜ë¥¼ ì²´í¬ì•„ì›ƒí•˜ì—¬ ê°œë°œ ë¸Œëœì¹˜ì— ë³€ê²½ ì‚¬í•­ ì ìš©
          ref: develop
          fetch-depth: 0

      # ëˆ„ë½ ë‚ ì§œë¥¼ **í™•ì‹¤íˆ** ì±„ìš°ëŠ” ì•ˆì „ ë°±í•„
      - name: Backfill missing dates as empty rows (robust)
        id: backfill
        uses: actions/github-script@v7
        env:
          README_PATH: ${{ env.README_PATH }}
          START_DATE: ${{ env.START_DATE }}
        with:
          script: |
            const fs = require('fs');
            const path = process.env.README_PATH;
            if (!fs.existsSync(path)) { core.setFailed(`README not found: ${path}`); return; }

            let md = fs.readFileSync(path, 'utf8');
            const S='<!-- PROGRESS:START -->', E='<!-- PROGRESS:END -->';
            const si=md.indexOf(S), ei=md.indexOf(E);
            if (si<0 || ei<0 || ei<si) { core.setFailed('Progress markers not found'); return; }

            const before = md.slice(0, si+S.length);
            let   block  = md.slice(si+S.length, ei);
            const after  = md.slice(ei);

            const z=n=>String(n).padStart(2,'0');
            const toDate = s => { const [Y,M,D]=s.split('-').map(Number); return new Date(Y, M-1, D); };
            const toStr  = d => `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}`;

            // KST ì˜¤ëŠ˜ 00:00
            const kstNow = new Date(new Date().toLocaleString('en-US',{timeZone:'Asia/Seoul'}));
            const today  = new Date(kstNow.getFullYear(), kstNow.getMonth(), kstNow.getDate());

            // í‘œ ë¼ì¸ íŒŒì‹±
            const rawLines = block.split('\n');
            const clean = s => s.replace(/\r/g,'').trim();
            const isHeader = s => /^\|\s*Date\s*\|\s*Status\s*\|\s*Note\s*\|?\s*$/.test(s);
            const isDivider= s => /^\|\s*-+\s*\|\s*-+\s*\|\s*-+\s*\|?\s*$/.test(s);
            const rowRe = /^\|\s*(\d{4}-\d{2}-\d{2})\s*\|\s*([^|]*)\|\s*(.*?)\s*\|?\s*$/;

            // ë‚ ì§œ â†’ ì›ë³¸í–‰ ë§µ (ê¸°ì¡´ í–‰ ë³´ì¡´)
            const map = new Map();
            for (const l0 of rawLines) {
              const l = clean(l0);
              if (!l || isHeader(l) || isDivider(l)) continue;
              const m = l.match(rowRe);
              if (m) {
                const date = m[1];
                // ë§ˆì§€ë§‰ì— ë³¸ í–‰ìœ¼ë¡œ ìœ ì§€(ìˆ˜ì •ëœ ìµœì‹  í–‰ ìš°ì„ )
                map.set(date, `| ${m[1]} | ${m[2].trim()} | ${m[3].trim()} |`);
              }
            }

            // ì‹œì‘ì¼ ê³„ì‚°
            let start;
            const floorStr=(process.env.START_DATE||'').trim();
            if (floorStr) {
              start = toDate(floorStr);
            } else if (map.size) {
              // í‘œì— ìˆëŠ” ê°€ì¥ ì˜¤ë˜ëœ ë‚ ì§œ
              start = toDate([...map.keys()].sort()[0]);
            } else {
              // í‘œê°€ ë¹„ì–´ ìˆìœ¼ë©´ ì´ë²ˆ ë‹¬ 1ì¼
              start = new Date(today.getFullYear(), today.getMonth(), 1);
            }

            // ì—°ì† ë²”ìœ„ ìƒì„±í•´ì„œ ë¹ ì§„ ë‚ ì€ ë¹ˆ í–‰ìœ¼ë¡œ ì±„ì›€
            let changed = false;
            for (let d=new Date(start); d<=today; d.setDate(d.getDate()+1)) {
              const s = toStr(d);
              if (!map.has(s)) {
                map.set(s, `| ${s} |  |  |`);
                changed = true;
              }
            }

            // ë‚ ì§œ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì¬êµ¬ì„±
            const header='| Date       | Status | Note |\n|------------|--------|------|';
            const lines = [...map.keys()].sort((a,b)=> a<b ? 1 : -1).map(k=>map.get(k));
            const outBlock = '\n'+header+'\n'+lines.join('\n')+'\n';
            const out = before + outBlock + after;

            if (out !== md) {
              fs.writeFileSync(path, out, 'utf8');
              core.setOutput('changed','1');
            } else {
              core.setOutput('changed', changed ? '1' : '0');
            }

      # ê³¼ê±° ë¹ˆì¹¸/ğŸŸª â†’ âŒ, ì˜¤ëŠ˜ì€ ì œì™¸
      - name: Mark âŒ for all past empty cells (incl. ğŸŸª)
        id: close_mark
        uses: actions/github-script@v7
        env:
          README_PATH: ${{ env.README_PATH }}
          START_DATE: ${{ env.START_DATE }}
        with:
          script: |
            const fs = require('fs');
            const path = process.env.README_PATH;
            if (!fs.existsSync(path)) { core.setFailed(`README not found: ${path}`); return; }

            let md = fs.readFileSync(path, 'utf8');
            const S='<!-- PROGRESS:START -->', E='<!-- PROGRESS:END -->';
            const si=md.indexOf(S), ei=md.indexOf(E);
            if (si<0 || ei<0 || ei<si) { core.setFailed('Progress markers not found'); return; }

            const before = md.slice(0, si+S.length);
            let   block  = md.slice(si+S.length, ei);
            const after  = md.slice(ei);

            const clean = s => s.replace(/\r/g,'').trim();
            const isHeader = s => /^\|\s*Date\s*\|\s*Status\s*\|\s*Note\s*\|?\s*$/.test(s);
            const isDivider= s => /^\|\s*-+\s*\|\s*-+\s*\|\s*-+\s*\|?\s*$/.test(s);
            const rowRe = /^\|\s*(\d{4}-\d{2}-\d{2})\s*\|\s*([^|]*)\|\s*(.*?)\s*\|?\s*$/;

            const z=n=>String(n).padStart(2,'0');
            const toDate = s => { const [Y,M,D]=s.split('-').map(Number); return new Date(Y, M-1, D); };
            const kstNow = new Date(new Date().toLocaleString('en-US',{timeZone:'Asia/Seoul'}));
            const today  = new Date(`${kstNow.getFullYear()}-${z(kstNow.getMonth()+1)}-${z(kstNow.getDate())}T00:00:00`);

            const floorStr=(process.env.START_DATE||'').trim();
            const hasFloor=!!floorStr;
            const floor   = hasFloor? toDate(floorStr): null;

            const isEmpty = s => ['','â¬œ','ğŸŸª'].includes(String(s).trim());

            const outLines = [];
            let changed=false;

            for (const l0 of block.split('\n')) {
              const l = clean(l0);
              if (!l || isHeader(l) || isDivider(l)) continue;
              const m = l.match(rowRe);
              if (!m) { outLines.push(l0); continue; }

              const [_, dateStr, statusRaw, noteRaw] = m;
              const d = toDate(dateStr);
              if ((hasFloor && d<floor) || !(d<today)) { outLines.push(`| ${dateStr} | ${statusRaw.trim()} | ${noteRaw.trim()} |`); continue; }

              if (isEmpty(statusRaw)) {
                outLines.push(`| ${dateStr} | âŒ | ${noteRaw.trim()} |`);
                changed = true;
              } else {
                outLines.push(`| ${dateStr} | ${statusRaw.trim()} | ${noteRaw.trim()} |`);
              }
            }

            const header='| Date       | Status | Note |\n|------------|--------|------|';
            const outBlock = '\n'+header+'\n'+outLines.join('\n')+'\n';
            const out = before + outBlock + after;

            if (out !== md) {
              fs.writeFileSync(path, out, 'utf8');
              core.setOutput('changed','1');
            } else {
              core.setOutput('changed', changed ? '1' : '0');
            }
            
            # ë³€ê²½ì´ ìˆìœ¼ë©´ develop ë¸Œëœì¹˜ ëŒ€ìƒìœ¼ë¡œ PR ìƒì„±
            - name: Create PR to develop
              if: steps.backfill.outputs.changed == '1' || steps.close_mark.outputs.changed == '1'
              uses: peter-evans/create-pull-request@v6
              with:
                token: ${{ secrets.GITHUB_TOKEN }}
                # develop ë¸Œëœì¹˜ë¡œì˜ PRì„ ë§Œë“¤ì–´ developì˜ READMEë¥¼ ì—…ë°ì´íŠ¸
                base: develop
                branch: automation/daily-close
                branch-suffix: timestamp
                # PRì´ ë³‘í•©ëœ ë’¤ ìë™ìœ¼ë¡œ ì†ŒìŠ¤ ë¸Œëœì¹˜ë¥¼ ì‚­ì œ
                delete-branch: true
                title: "chore: daily close (robust backfill & close past blanks)"
                commit-message: "chore: daily close (robust backfill & close past blanks)"
                add-paths: ${{ env.README_PATH }}
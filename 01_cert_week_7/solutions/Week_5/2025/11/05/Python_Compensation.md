좋아, 이제 컴프리헨션 맛을 봤으니 중독 오기 딱 좋을 때다. 남용만 안 하면 생산성이 확 치솟는다. 핵심만 구조적으로 잡아줄게. 너 수준부터 살짝만 확인: 파이썬 기초 문법은 편하게 쓰고, 리스트/딕셔너리 정도는 알고 있다는 전제로 갈게.

# 1) 왜 생겼나: “표현식으로 컬렉션 만들기”

예전엔 이렇게 썼다:

```python
out = []
for x in data:
    if cond(x):
        out.append(f(x))
```

이 패턴이 너무 흔해서 파이썬이 “선언적 한 줄”로 축약한 게 **컴프리헨션**. 읽기 쉬워지고, 속도도 보통 더 빠르다.

# 2) 기본 형태(읽는 순서까지)

리스트:

```python
[f(x) for x in iterable if cond(x)]
```

읽는 순서: “x를 순회하면서 cond면 f(x)를 뽑아 리스트로 만든다.”

* `f(x)` 부분: **무엇을 담을지** (표현식)
* `for x in iterable`: **어디서 뽑을지** (루프)
* `if cond(x)`: **필터** (선택)

집합/딕셔너리도 같은 원리:

```python
{k(x) for x in iterable if cond(x)}                 # set
{key(x): val(x) for x in iterable if cond(x)}       # dict
```

# 3) 자주 틀리는 포인트 5가지

1. **표현식 자리에 문**을 넣으려 함
   컴프리헨션의 앞부분은 “표현식”만 가능. `append` 같은 건 문맥상 불가.
2. **중첩을 과하게** 씀
   `for`가 2개 넘어가면 가독성 추락. 그때는 함수로 빼거나 명시적 for문으로.
3. **if 위치** 헷갈림
   필터는 맨 뒤(`... for x in it if cond(x)`)에 두는 게 관례. `f(x) if ... else g(x)` 같은 **삼항연산자**는 앞 표현식 자리에서만.
4. **딕셔너리 키 중복**
   `{k(x): v(x) for ...}`에서 `k(x)`가 중복되면 마지막 값이 덮어쓴다. 의도했는지 확인.
5. **부작용(side effect) 기대**
   컴프리헨션은 반환값을 만드는 용도. 로그 찍기, 외부 상태 변경 등은 얌전히 for문으로.

# 4) 실수 안 하는 패턴들(안전 레시피)

* **필터 먼저, 변환 나중**:
  필터를 뒤에 두고, 앞은 “담을 값”만 깔끔히:

  ```python
  [f(x) for x in data if good(x)]
  ```
* **집합 컴프리헨션으로 중복 제거**:

  ```python
  {norm(s) for s in strings if s}
  ```
* **딕셔너리 만들 때 키/값 분리 명확히**:

  ```python
  {user.id: user.name for user in users if user.active}
  ```
* **조건부 값 선택은 삼항연산자**:

  ```python
  [x if x % 2 else 0 for x in nums]   # 짝수는 0으로
  ```
* **중첩이 필요할 땐 순서 의식**:

  ```python
  pairs = [(a, b) for a in A for b in B if ok(a, b)]
  # 바깥 for가 A, 안쪽 for가 B
  ```

# 5) 리스트 vs 제너레이터: 메모리 감각

* **리스트 컴프리헨션**: 즉시 계산, 메모리 소비 큼.
* **제너레이터 표현식**: 괄호만 바꾸면 지연계산.

  ```python
  gen = (f(x) for x in huge)  # 필요한 순간에만 값 생성
  ```

  파이프라인에 넘길 때 유용:

  ```python
  sum(f(x) for x in huge if cond(x))
  ```

# 6) 성능과 가독성

* 보통 **컴프리헨션 ≥ for문 + append**. 파이썬 내부 루프가 빠르다.
* 하지만 가독성이 떨어지는 한 줄 괴물은 성능보다 팀원들 멘탈에 해롭다. 2중 루프 넘어가면 함수로 쪼개라.

# 7) 미니 연습(한 번에 하나만)

다음 요구를 **리스트 컴프리헨션**으로 써 봐:

> 주어진 정수 리스트 `nums`에서, 0보다 큰 값만 제곱해서 리스트로 만들기.

